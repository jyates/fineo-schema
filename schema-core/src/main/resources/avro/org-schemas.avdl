// Schemas for managing schemas in an organization
//
// The top level protocol is merely a wrapper to use the IDL.
// The parts we care about are the actual record instances
//
// The layering and instance/schema is a bit round about, but allows us to dynamically rename both
// the metric types and the fields in a metric instance because they are actually stored under a
// canonical name. We cannot use the Avro alias for records b/c it does not support full string
// names.


@namespace("io.fineo.internal.customer")
protocol Organization {

  record Metadata {
    // version of this metadata
    string version = "0";
     // basically, the id
     string canonicalName;
  }

  // Metadata about a metric in an org
  record OrgMetricMetadata {
    // other keys besides 'metrictype' to identify the metric
    array<string> aliasKeys;
    // values that indicate the record belongs to this metric (aka. aliases for the canonical name)
    array<string> aliasValues;
    // name that the metric should be displayed as. This is just one of the aliases
    string displayName;
  }

  // Metadata about an organization
  record OrgMetadata {
    Metadata metadata;

    // helper record to map a canonical name to a number of aliases
    union {null, map<OrgMetricMetadata>} canonicalNamesToAliases = null;
  }

  // Metadata about a metric to store with a metric
  record MetricMetadata {
    Metadata meta;
    union {null, map<string>} canonicalNamesToAliases = null;
  }

  // A metric's schema in an organization.
  //
  // While this defines a schema, the actual schema of a metric is an _instance_ of this class
  // It will store the metric's canonical name  (used to look it up in the
  // parent's metadata), the field map for the actual metric's fields (name -> aliases) and then
  // the schema of the actual metric itself.
  record Metric {
    // its 'a' metadata, but not 'the' metadata
    Metadata metadata;
    // optional map of fieldname -> delete time
    union{null, map<long>} hidden_time = null;
    // actual schema
    string metricSchema;
  }

  // The base fields that are assumed to be in any BaseRecord
  record BaseFields {
    // timestamp of the event
    long timestamp;
    // fields for which we don't have any schema from the user
    map<string> unknown_fields;
  }

  // Base components of a field. In code we add the actual data type to the instance. This also
  // saves having a huge record schema with all the different possible data types
  record FieldInstance {
    // name the user specified for the field. Maps to an alias name, under a canonical name, in the
    // Metric's Metadata canonicalNameToAlias map
    string displayName;
  }

  // The base record instance that we use to build a metric type schema. In code we add the desired
  // fields to create the full record
  record BaseRecord {
    BaseFields baseFields;
  }
}
