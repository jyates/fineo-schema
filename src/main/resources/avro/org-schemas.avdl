// Schemas for managing schemas in an organization
//
// The top level protocol is merely a wrapper to use the IDL.
// The parts we care about are the actual record instances
//
// The layering and instance/schema is a bit round about, but allows us to dynamically rename both
// the metric types and the fields in a metric instance because they are actually stored under a
// canonical name. We cannot use the Avro alias for records b/c it does not support full string
// names.


@namespace("io.fineo.internal.customer")
protocol Organization {
  // Metadata about an organization, specifically:
  // - the org ID
  // - the map of the metric cannonical and alias names
  //
  // Decoupled from metric instances to allow them to change independently
  record Metadata {
    // version of this metadata
    string version = "0";
    // basically, the id
    string canonicalName;
    // helper record to map a canonical name to a number of aliases
    union {null, map<array<string>>} canonicalNamesToAliases = null;
  }

  // A metric's schema in an organization.
  //
  // While this defines a schema, the actual schema of a metric is an _instance_ of this class
  // It will store the metric's canonical name  (used to look it up in the
  // parent's metadata), the field map for the actual metric's fields (name -> aliases) and then
  // the schema of the actual metric itself.
  record Metric {
    // its 'a' metadata, but not 'the' metadata
    Metadata metadata;
    // optional map of fieldname -> delete time
    union{null, map<long>} hidden_time = null;
    // actual schema
    string metricSchema;
  }

  // The base fields that are assumed to be in any BaseRecord
  record BaseFields {
    // user specified name of the metric, which is aliased to an internal canonical name
    string aliasName;
    // timestamp of the event
    long timestamp;
    // fields for which we don't have any schema from the user
    map<string> unknown_fields;
  }

  // Base components of a field. In code we add the actual data type to the instance. This also
  // saves having a huge record schema with all the different possible data types
  record FieldInstance {
    // name the user specified for the field. Maps to an alias name, under a canonical name, in the
    // Metric's Metadata canonicalNameToAlias map
    string fieldAliasName;
  }

  // The base record instance that we use to build a metric type schema. In code we add the desired
  // fields to create the full record
  record BaseRecord {
    BaseFields baseFields;
  }
}
