// Schemas for managing schemas in an organization
//
// The top level protocol is merely a wrapper to use the IDL.
// The parts we care about are the actual record instances
//
// The layering and instance/schema is a bit round about, but allows us to dynamically rename both
// the metric types and the fields in a metric instance because they are actually stored under a
// canonical name. We cannot use the Avro alias for records b/c it does not support full string
// names.


@namespace("io.fineo.internal.customer")
protocol Organization{
  // Metadata about an organization, specifically:
  // - the org ID
  // - the map of the metric cannonical and alias names
  //
  // Decoupled from metric instances to allow them to change independently
  record Metadata {
    string canonicalName;
    // helper record to map a canonical name to a number of aliases
    union {null, map<array<string>>} canonicalNamesToAliases = null;
  }

  // A metric's schema in an organization.
  //
  // While this defines a schema, the actual schema of a metric is an _instance_ of this class
  // It will store the metric's canonical name  (used to look it up in the
  // parent's metadata), the field map for the actual metric's fields (name -> aliases) and then
  // the schema of the actual metric itself.
  record Metric{
    // its 'a' metadata, but not 'the' metadata
    Metadata metadata;
    // optional map of fieldname -> delete time
    union{null, map<long>} hidden_time = null;
    // actual schema
    string metricSchema;
  }

  // The base fields that are assumed to be in any BaseRecord
  record BaseFields{
    string aliasName;
    long timestamp;
    map<string> unknown_fields;
  }

  // The base record instance that we use to build a metric type schema. In code we add the desired
  // fields to create the full record
  record BaseRecord {
    BaseFields baseFields;
  }
}